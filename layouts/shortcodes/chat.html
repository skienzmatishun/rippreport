<div id="comment-section" data-section="{{ index .Params 0 }}"></div>
<script
  type="text/javascript"
  src="https://rippreport.com/js/cactus.js"
></script>
<link href="https://rippreport.com/css/comments.css" rel="stylesheet" />
<script>
  initComments({
    node: document.getElementById("comment-section"),
    defaultHomeserverUrl: "https://matrix.cactus.chat:8448",
    serverName: "cactus.chat",
    siteName: "rippreport.com",
    pageSize: 15,
    commentSectionId: "{{ index .Params 0 }}",
  });

  // Predefined palette of 15 distinct colors
  const colorPalette = [
    "#F44336", // Red
    "#4CAF50", // Green
    "#2196F3", // Blue
    "#FFC107", // Amber
    "#9C27B0", // Purple
    "#FF9800", // Orange
    "#00BCD4", // Cyan
    "#8BC34A", // Light Green
    "#FFEB3B", // Yellow
    "#E91E63", // Pink
    "#607D8B", // Blue Grey
    "#3F51B5", // Indigo
    "#009688", // Teal
    "#795548", // Brown
    "#673AB7", // Deep Purple
  ];

  function getColorForUsername(username) {
    let hash = 0;
    for (let i = 0; i < username.length; i++) {
      hash = username.charCodeAt(i) + ((hash << 5) - hash);
    }
    // Use the hash to select a color from our palette
    const colorIndex = Math.abs(hash % colorPalette.length);
    return colorPalette[colorIndex];
  }

  // Function to apply colors to comments
  function applyCommentColors() {
    document.querySelectorAll(".cactus-comment").forEach((comment) => {
      const displayNameLink = comment.querySelector(
        ".cactus-comment-displayname"
      );
      const username = displayNameLink.href.split("/").pop(); // Extract username from link
      // Check if the username exists before applying the color
      if (username) {
        // Get and set the border-left color based on the username
        const borderColor = getColorForUsername(username);
        comment.style.borderLeft = `5px solid ${borderColor}`; // Adjust the width as necessary
      }
    });
  }

  // Create a Mutation Observer to watch for changes in the comments container
  const commentsContainer = document.querySelector(
    ".cactus-comments-container"
  );
  const observer = new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.addedNodes.length || mutation.removedNodes.length) {
        // New comments have been added or removed, apply colors
        applyCommentColors();
      }
    }
  });

  // Start observing the comments container for child node changes
  if (commentsContainer) {
    observer.observe(commentsContainer, { childList: true, subtree: true });
  }

  // Function to apply colors after initial delay, and then again after another delay
  function delayedColorApplication() {
    setTimeout(() => {
      applyCommentColors(); // First application after 3000ms
      setTimeout(applyCommentColors, 5000); // Second application after another 5000ms
    }, 3000);
  }

  // Start the color application process
  delayedColorApplication();

  // Create a Mutation Observer for detecting when the button is added to the DOM
  const buttonObserver = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      mutation.addedNodes.forEach((node) => {
        if (node.classList && node.classList.contains("cactus-button")) {
          // Button found, add the event listener
          node.addEventListener("click", () => {
            setTimeout(() => {
              applyCommentColors();
            }, 2000);
          });
          // Once button is found and listener added, disconnect observer
          buttonObserver.disconnect();
        }
      });
    });
  });

  // Start observing the document for the addition of the button
  buttonObserver.observe(document.body, { childList: true, subtree: true });

  // Cactus Comments Reply System
  class CactusReplySystem {
    constructor() {
      console.log("CactusReplySystem constructor called");
      this.replyButtons = new Map();
      this.currentQuote = null;
      this.quoteContainer = null;
      this.init();
    }

    init() {
      console.log("Initializing reply system");
      this.waitForComments();
      this.setupMutationObserver();
      this.createQuoteContainer();
    }

    waitForComments() {
      console.log("Waiting for comments to load");

      const checkForComments = () => {
        const comments = document.querySelectorAll(".cactus-comment");
        console.log(`Found ${comments.length} comments`);

        if (comments.length > 0) {
          this.addReplyButtons();
        } else {
          setTimeout(checkForComments, 1000);
        }
      };
      checkForComments();
    }

    setupMutationObserver() {
      const commentsContainer = document.querySelector("#comment-section");
      if (!commentsContainer) return;

      const observer = new MutationObserver((mutations) => {
        let shouldUpdate = false;
        mutations.forEach((mutation) => {
          if (mutation.addedNodes.length > 0) {
            mutation.addedNodes.forEach((node) => {
              if (
                node.nodeType === 1 &&
                (node.classList?.contains("cactus-comment") ||
                  node.querySelector?.(".cactus-comment"))
              ) {
                shouldUpdate = true;
              }
            });
          }
        });

        if (shouldUpdate) {
          console.log("New comments detected, adding reply buttons");
          setTimeout(() => this.addReplyButtons(), 500);
        }
      });

      observer.observe(commentsContainer, {
        childList: true,
        subtree: true,
      });
    }

    addReplyButtons() {
      const comments = document.querySelectorAll(".cactus-comment");
      console.log(`Adding reply buttons to ${comments.length} comments`);

      comments.forEach((comment, index) => {
        const commentData = this.extractCommentData(comment, index);
        console.log(
          `Comment ${index}: name = ${commentData.name}, timestamp = ${commentData.timestamp}`
        );
        
        // Skip if we already have a button for this comment
        if (this.replyButtons.has(commentData.timestamp)) {
          console.log(`Skipping comment ${index} - already has reply button`);
          return;
        }

        const replyButton = this.createReplyButton(commentData);

        // Try multiple locations to insert the reply button
        let insertLocation = comment.querySelector(".cactus-comment-body");
        if (!insertLocation) {
          insertLocation = comment.querySelector(".cactus-comment-content");
        }
        if (!insertLocation) {
          insertLocation = comment.querySelector(".cactus-message-text");
        }
        if (!insertLocation) {
          // Find any container within the comment that has text content
          const textContainers = comment.querySelectorAll("div, p, span");
          for (let container of textContainers) {
            if (container.textContent.trim().length > 10) { // Has substantial content
              insertLocation = container;
              break;
            }
          }
        }
        if (!insertLocation) {
          // Last resort: append to the comment itself
          insertLocation = comment;
        }

        if (insertLocation) {
          insertLocation.appendChild(replyButton);
          this.replyButtons.set(commentData.timestamp, replyButton);
          console.log(`Added reply button for comment by ${commentData.name} at location:`, insertLocation.className);
        } else {
          console.log(`Could not find suitable location for reply button in comment ${index}`);
        }
      });
    }

    extractCommentData(comment, index = 0) {
      // Extract the display name - focus on the actual display name from the Name field
      let name = "Anonymous";
      let matrixUsername = null;
      
      // First, try to get the display name element
      const displayNameElement = comment.querySelector(".cactus-comment-displayname");
      
      if (displayNameElement) {
        // Get the text content directly - this should be the display name from the Name field
        let nameText = displayNameElement.textContent.trim();
        
        // Also extract the Matrix username from the href for unique identification
        if (displayNameElement.href) {
          matrixUsername = displayNameElement.href.split("/").pop();
        }
        
        // Clean up the name text and use it if it's valid
        if (nameText && nameText.length > 0 && nameText.toLowerCase() !== 'reply') {
          // Remove any extra whitespace and special characters that might interfere
          name = nameText.replace(/^\s+|\s+$/g, '').replace(/\s+/g, ' ');
        }
      }
      
      // If we still don't have a good name, try alternative selectors
      if (name === "Anonymous" || name.toLowerCase() === 'reply' || name.length === 0) {
        // Try other possible selectors for the display name
        const alternativeSelectors = [
          '.cactus-comment-header .cactus-comment-displayname',
          '.cactus-comment-content .cactus-comment-displayname', 
          '[class*="displayname"]',
          '[class*="username"]',
          '.comment-author',
          '.author-name'
        ];
        
        for (let selector of alternativeSelectors) {
          const element = comment.querySelector(selector);
          if (element) {
            let text = element.textContent.trim();
            if (text && text.length > 0 && text.toLowerCase() !== 'reply') {
              name = text.replace(/^\s+|\s+$/g, '').replace(/\s+/g, ' ');
              
              // Also try to get Matrix username from this element
              if (element.href && !matrixUsername) {
                matrixUsername = element.href.split("/").pop();
              }
              break;
            }
          }
        }
      }

      // Extract the original message content
      const messageElement = comment.querySelector(
        ".cactus-message-text, .cactus-comment-body .cactus-message-text"
      );
      let originalMessage = "";
      if (messageElement) {
        originalMessage = messageElement.textContent.trim();
      } else {
        // Fallback: try to get text from comment body, excluding the header
        const commentBody = comment.querySelector(".cactus-comment-body");
        if (commentBody) {
          // Clone the element to avoid modifying the original
          const bodyClone = commentBody.cloneNode(true);
          // Remove any reply buttons we might have added
          const replyButtons = bodyClone.querySelectorAll(
            ".cactus-reply-button, .cactus-reply-container"
          );
          replyButtons.forEach((btn) => btn.remove());
          originalMessage = bodyClone.textContent.trim();
        }
      }

      // Extract timestamp for unique identification - be more flexible
      let timestamp;
      const timeElement = comment.querySelector(".cactus-comment-time, time, [class*='time'], [class*='date']");
      
      if (timeElement && timeElement.dateTime) {
        timestamp = timeElement.dateTime;
      } else if (timeElement) {
        timestamp = timeElement.textContent.trim();
      } else {
        // Try to find any timestamp-like content
        const timestampElements = comment.querySelectorAll('[datetime], [data-timestamp], [class*="timestamp"]');
        for (let elem of timestampElements) {
          if (elem.dateTime) {
            timestamp = elem.dateTime;
            break;
          } else if (elem.dataset.timestamp) {
            timestamp = elem.dataset.timestamp;
            break;
          }
        }
      }
      
      // Create a unique identifier using position and content to ensure every comment gets a unique ID
      let uniqueId;
      
      // Always include the index to ensure uniqueness
      const baseId = `comment_${index}`;
      
      if (timestamp) {
        // Combine position, timestamp, and content hash
        const contentHash = this.generateHash(name + originalMessage + comment.textContent.trim());
        uniqueId = `${baseId}_${timestamp}_${contentHash}`;
      } else {
        const commentId = comment.id || comment.dataset.id;
        if (commentId) {
          uniqueId = `${baseId}_${commentId}`;
        } else {
          // Use position and content hash
          const contentHash = this.generateHash(name + originalMessage + comment.textContent.trim());
          uniqueId = `${baseId}_${contentHash}`;
        }
      }

      console.log(`Extracted comment data: name="${name}", matrixUsername="${matrixUsername}", uniqueId="${uniqueId}", message="${originalMessage.substring(0, 50)}..."`);
      return { name, matrixUsername, timestamp: uniqueId, originalMessage };
    }

    generateHash(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
      }
      return Math.abs(hash).toString();
    }

    createReplyButton(commentData) {
      const button = document.createElement("button");
      button.className = "cactus-reply-button";
      button.textContent = "Reply";
      button.style.cssText = `
            background: #007cba;
            color: white;
            border: none;
            padding: 4px 8px;
            border-radius: 3px;
            font-size: 12px;
            cursor: pointer;
            margin-top: 8px;
            margin-right: 8px;
            transition: background-color 0.2s;
        `;

      button.addEventListener("mouseenter", () => {
        button.style.backgroundColor = "#005a87";
      });

      button.addEventListener("mouseleave", () => {
        button.style.backgroundColor = "#007cba";
      });

      button.addEventListener("click", (e) => {
        e.preventDefault();
        this.handleReplyClick(commentData);
      });

      return button;
    }

    handleReplyClick(commentData) {
      console.log("Reply button clicked for:", commentData.name);

      // Ensure quote container exists before trying to show quote
      if (!this.quoteContainer) {
        console.log("Quote container not ready, creating it now...");
        this.createQuoteContainer();
        // Wait a bit for container to be created, then try again
        setTimeout(() => {
          this.showQuote(commentData);
          this.clearMainTextarea();
          this.scrollToMainForm();
        }, 100);
      } else {
        // Show the quote in the visual container
        this.showQuote(commentData);
        // Clear the textarea (don't put quote text in it)
        this.clearMainTextarea();
        // Scroll to the main comment form
        this.scrollToMainForm();
      }
    }

    getUserColor(commentData) {
      console.log("Getting color for user:", commentData.name, "Matrix username:", commentData.matrixUsername);
      
      // Find the comment that matches this data using the unique Matrix username
      const comments = document.querySelectorAll(".cactus-comment");
      for (let comment of comments) {
        const displayNameElement = comment.querySelector(".cactus-comment-displayname");
        if (displayNameElement && displayNameElement.href) {
          const commentMatrixUsername = displayNameElement.href.split("/").pop();
          
          // Match by Matrix username (unique) instead of display name (not unique)
          if (commentMatrixUsername === commentData.matrixUsername) {
            console.log("Found matching comment by Matrix username:", commentMatrixUsername);
            
            // Try to get the computed border color
            const computedStyle = window.getComputedStyle(comment);
            const borderColor = computedStyle.borderLeftColor;
            
            if (borderColor && borderColor !== 'rgba(0, 0, 0, 0)' && borderColor !== 'transparent') {
              console.log("Found border color:", borderColor);
              return borderColor;
            }
            
            // If no computed border color, calculate it from the Matrix username
            if (commentMatrixUsername) {
              const calculatedColor = getColorForUsername(commentMatrixUsername);
              console.log("Calculated color from Matrix username:", calculatedColor);
              return calculatedColor;
            }
          }
        }
      }
      
      // Fallback: if we have a Matrix username, calculate color from it
      if (commentData.matrixUsername) {
        const fallbackColor = getColorForUsername(commentData.matrixUsername);
        console.log("Using fallback color from Matrix username:", fallbackColor);
        return fallbackColor;
      }
      
      console.log("No matching comment found, using default color");
      // Final fallback: return default blue color
      return "#007cba";
    }

    createQuoteContainer() {
      // Don't create if it already exists
      if (this.quoteContainer) return;
      
      // Wait for the cactus editor to be available
      const checkForEditor = () => {
        const cactusEditor = document.querySelector(".cactus-editor");
        if (cactusEditor && !this.quoteContainer) {
          this.quoteContainer = document.createElement("div");
          this.quoteContainer.className = "reply-quote-container";
          this.quoteContainer.style.cssText = `
            display: none;
            margin-bottom: 10px;
            padding: 12px;
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-left: 4px solid #007cba;
            border-radius: 4px;
            font-size: 14px;
            position: relative;
          `;

          // Insert before the textarea
          const textarea = cactusEditor.querySelector(
            ".cactus-editor-textarea"
          );
          if (textarea) {
            cactusEditor.insertBefore(this.quoteContainer, textarea);
            console.log("Quote container created and inserted");
          }
        } else if (!cactusEditor) {
          setTimeout(checkForEditor, 500);
        }
      };
      checkForEditor();
    }

    showQuote(commentData) {
      if (!this.quoteContainer) return;

      this.currentQuote = commentData;

      // Limit the original message to 200 characters
      let truncatedMessage =
        commentData.originalMessage || "No message content";
      if (truncatedMessage.length > 200) {
        truncatedMessage = truncatedMessage.substring(0, 200) + "...";
      }

      this.quoteContainer.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: flex-start;">
          <div style="flex: 1;">
            <div style="
              display: flex; 
              align-items: center; 
              gap: 8px; 
              margin-bottom: 8px;
              font-weight: bold; 
              color: #007cba; 
              font-size: 16px;
            ">
              <span style="
                background: #007cba;
                color: white;
                padding: 2px 8px;
                border-radius: 12px;
                font-size: 12px;
                text-transform: uppercase;
                letter-spacing: 0.5px;
              ">REPLY MODE</span>
              <span>Replying to ${commentData.name}</span>
            </div>
            <div style="
              font-style: italic; 
              color: #666; 
              line-height: 1.4;
              padding: 8px;
              background: rgba(0, 124, 186, 0.05);
              border-radius: 4px;
              border-left: 3px solid #007cba;
            ">
              "${truncatedMessage}"
            </div>
          </div>
          <button class="quote-close-btn" style="
            background: none;
            border: none;
            font-size: 20px;
            color: #999;
            cursor: pointer;
            padding: 4px;
            margin-left: 10px;
            line-height: 1;
            border-radius: 50%;
            width: 28px;
            height: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
          " title="Cancel reply">&times;</button>
        </div>
      `;

      // Add close button functionality
      const closeBtn = this.quoteContainer.querySelector(".quote-close-btn");
      closeBtn.addEventListener("click", () => this.hideQuote());
      
      // Add hover effect to close button
      closeBtn.addEventListener("mouseenter", () => {
        closeBtn.style.backgroundColor = "rgba(255, 0, 0, 0.1)";
        closeBtn.style.color = "#ff4444";
      });
      
      closeBtn.addEventListener("mouseleave", () => {
        closeBtn.style.backgroundColor = "transparent";
        closeBtn.style.color = "#999";
      });

      this.quoteContainer.style.display = "block";
      
      // Add visual indication to the editor
      this.setReplyMode(true);
    }

    hideQuote() {
      if (this.quoteContainer) {
        this.quoteContainer.style.display = "none";
        this.currentQuote = null;
        this.setReplyMode(false);
      }
    }

    setReplyMode(isReplyMode) {
      const cactusEditor = document.querySelector(".cactus-editor");
      const textarea = document.querySelector(".cactus-editor-textarea");
      
      if (!cactusEditor || !textarea) return;

      if (isReplyMode && this.currentQuote) {
        // Get the user's color from their comment
        const userColor = this.getUserColor(this.currentQuote);
        
        // Add reply mode styling
        cactusEditor.classList.add("reply-mode");
        textarea.placeholder = `Write your reply to ${this.currentQuote.name} here...`;
        
        // Add glow effect with the user's color and remove default focus styles
        textarea.style.setProperty('box-shadow', `0 0 0 3px ${userColor}40`, 'important'); // 40 is hex for 25% opacity, 3px border
        textarea.style.setProperty('border-color', userColor, 'important');
        textarea.style.setProperty('outline', 'none', 'important'); // Remove default focus outline
        
      } else {
        // Remove reply mode styling
        cactusEditor.classList.remove("reply-mode");
        textarea.placeholder = "Leave a comment";
        
        // Remove glow effect and reset outline
        textarea.style.removeProperty('box-shadow');
        textarea.style.removeProperty('border-color');
        textarea.style.removeProperty('outline');
      }
    }

    clearMainTextarea() {
      const mainTextarea = document.querySelector(".cactus-editor-textarea");
      if (mainTextarea) {
        mainTextarea.value = "";
        const event = new Event("input", { bubbles: true });
        mainTextarea.dispatchEvent(event);
      }
    }

    interceptSubmit() {
      // Find the cactus editor and intercept form submission
      const checkForEditor = () => {
        const cactusEditor = document.querySelector(".cactus-editor");
        const sendButton = document.querySelector(".cactus-send-button");

        if (cactusEditor && sendButton && !sendButton.dataset.intercepted) {
          sendButton.dataset.intercepted = "true";

          sendButton.addEventListener("click", (e) => {
            if (this.currentQuote) {
              e.preventDefault();
              this.handleSubmitWithQuote();
            }
          });
        } else {
          setTimeout(checkForEditor, 1000);
        }
      };
      setTimeout(checkForEditor, 3000);
    }

    handleSubmitWithQuote() {
      const mainTextarea = document.querySelector(".cactus-editor-textarea");
      if (!mainTextarea || !this.currentQuote) return;

      const userText = mainTextarea.value.trim();
      
      // Don't allow empty replies
      if (!userText) {
        alert("Please write a reply before posting.");
        mainTextarea.focus();
        return;
      }

      const quoteText = this.formatQuoteForPost(this.currentQuote);

      // Combine quote and user text
      const finalText = quoteText + `\n\n${userText}`;

      // Set the combined text
      mainTextarea.value = finalText;

      // Trigger the input event
      const event = new Event("input", { bubbles: true });
      mainTextarea.dispatchEvent(event);

      // Hide the quote container
      this.hideQuote();

      // Trigger the actual submit after a brief delay
      setTimeout(() => {
        const sendButton = document.querySelector(".cactus-send-button");
        if (sendButton) {
          sendButton.click();
        }
      }, 100);
    }

    formatQuoteForPost(commentData) {
      let truncatedMessage =
        commentData.originalMessage || "No message content";
      if (truncatedMessage.length > 200) {
        truncatedMessage = truncatedMessage.substring(0, 200) + "...";
      }
      return `**@Reply to ${commentData.name}:**\n*${truncatedMessage}*`;
    }

    scrollToMainForm() {
      // Target the specific cactus editor textarea
      let mainForm = document.querySelector(".cactus-editor-textarea");

      console.log("Scrolling to main form:", mainForm);
      if (mainForm) {
        mainForm.scrollIntoView({ behavior: "smooth", block: "center" });
        // Focus the textarea after scrolling
        setTimeout(() => mainForm.focus(), 100);
      } else {
        console.log("Could not find .cactus-editor-textarea to scroll to");
      }
    }

    copyToClipboard(text) {
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(text);
      } else {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed";
        textArea.style.left = "-999999px";
        textArea.style.top = "-999999px";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();

        try {
          document.execCommand("copy");
        } catch (err) {
          console.error("Failed to copy text: ", err);
        }

        document.body.removeChild(textArea);
      }
    }
  }

  // Initialize the reply system after cactus is fully loaded
  console.log("Setting up reply system initialization");

  // Wait for cactus to be fully initialized before adding our functionality
  function waitForCactusReady() {
    const cactusEditor = document.querySelector(".cactus-editor");
    const cactusTextarea = document.querySelector(".cactus-editor-textarea");

    if (cactusEditor && cactusTextarea) {
      console.log("Cactus is ready, creating CactusReplySystem instance");
      const replySystem = new CactusReplySystem();
      replySystem.interceptSubmit();
    } else {
      console.log("Cactus not ready yet, retrying...");
      setTimeout(waitForCactusReady, 1000);
    }
  }

  // Start checking after a delay to let cactus initialize
  setTimeout(waitForCactusReady, 5000);

  // New script for infinite scroll
  const commentsContainerForScroll = document.querySelector("#comment-section");
  let isLoading = false;
  let page = 1;
  let allPosts = [];

  async function fetchAndInjectPosts() {
    if (isLoading) return;
    isLoading = true;

    try {
      const response = await fetch(`/page/${page}/index.json`);
      if (!response.ok) {
        console.error("Failed to fetch posts");
        isLoading = false;
        return;
      }
      const newPosts = await response.json();
      
      if (newPosts.length > 0) {
        const newPostsContainer = document.createElement("div");
        let newPostsHtml = '';
        newPosts.forEach(post => {
          newPostsHtml += `
            <div class="post-placeholder">
              <h3><a href="${post.permalink}">${post.title}</a></h3>
              <p>${post.summary}</p>
            </div>
          `;
        });
        newPostsContainer.innerHTML = newPostsHtml;
        document.querySelector('.main-content').appendChild(newPostsContainer); // Adjust selector if needed
        page++;
      }
    } catch (error) {
      console.error("Error fetching posts:", error);
    } finally {
      isLoading = false;
    }
  }

  function checkWhitespaceAndLoad() {
    const viewportHeight = window.innerHeight;
    const contentHeight = document.body.scrollHeight;
    const scrollPosition = window.scrollY;

    if (contentHeight - (scrollPosition + viewportHeight) < 200) { // Load when 200px from bottom
      fetchAndInjectPosts();
    }
  }

  const scrollObserver = new MutationObserver(() => {
    checkWhitespaceAndLoad();
    window.addEventListener("scroll", checkWhitespaceAndLoad);
  });

  if (commentsContainerForScroll) {
    scrollObserver.observe(commentsContainerForScroll, {
      childList: true,
      subtree: true,
    });
  }
</script>

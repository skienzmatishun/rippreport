<div id="comment-section" data-section="{{ index .Params 0 }}"></div>
<script
  type="text/javascript"
  src="https://rippreport.com/js/cactus.js"
></script>
<link href="https://rippreport.com/css/comments.css" rel="stylesheet" />
<script>
  initComments({
    node: document.getElementById("comment-section"),
    defaultHomeserverUrl: "https://matrix.cactus.chat:8448",
    serverName: "cactus.chat",
    siteName: "rippreport.com",
    pageSize: 15,
    commentSectionId: "{{ index .Params 0 }}",
  });

  // Predefined palette of 15 distinct colors
  const colorPalette = [
    "#F44336", // Red
    "#4CAF50", // Green
    "#2196F3", // Blue
    "#FFC107", // Amber
    "#9C27B0", // Purple
    "#FF9800", // Orange
    "#00BCD4", // Cyan
    "#8BC34A", // Light Green
    "#FFEB3B", // Yellow
    "#E91E63", // Pink
    "#607D8B", // Blue Grey
    "#3F51B5", // Indigo
    "#009688", // Teal
    "#795548", // Brown
    "#673AB7", // Deep Purple
  ];

  function getColorForUsername(username) {
    let hash = 0;
    for (let i = 0; i < username.length; i++) {
      hash = username.charCodeAt(i) + ((hash << 5) - hash);
    }
    // Use the hash to select a color from our palette
    const colorIndex = Math.abs(hash % colorPalette.length);
    return colorPalette[colorIndex];
  }

  // Function to apply colors to comments
  function applyCommentColors() {
    document.querySelectorAll(".cactus-comment").forEach((comment) => {
      const displayNameLink = comment.querySelector(
        ".cactus-comment-displayname"
      );
      const username = displayNameLink.href.split("/").pop(); // Extract username from link
      // Check if the username exists before applying the color
      if (username) {
        // Get and set the border-left color based on the username
        const borderColor = getColorForUsername(username);
        comment.style.borderLeft = `5px solid ${borderColor}`; // Adjust the width as necessary
      }
    });
  }

  // Create a Mutation Observer to watch for changes in the comments container
  const commentsContainer = document.querySelector(
    ".cactus-comments-container"
  );
  const observer = new MutationObserver((mutations) => {
    for (const mutation of mutations) {
      if (mutation.addedNodes.length || mutation.removedNodes.length) {
        // New comments have been added or removed, apply colors
        applyCommentColors();
      }
    }
  });

  // Start observing the comments container for child node changes
  if (commentsContainer) {
    observer.observe(commentsContainer, { childList: true, subtree: true });
  }

  // Function to apply colors after initial delay, and then again after another delay
  function delayedColorApplication() {
    setTimeout(() => {
      applyCommentColors(); // First application after 3000ms
      setTimeout(applyCommentColors, 5000); // Second application after another 5000ms
    }, 3000);
  }

  // Start the color application process
  delayedColorApplication();

  // Create a Mutation Observer for detecting when the button is added to the DOM
  const buttonObserver = new MutationObserver((mutations) => {
    mutations.forEach((mutation) => {
      mutation.addedNodes.forEach((node) => {
        if (node.classList && node.classList.contains("cactus-button")) {
          // Button found, add the event listener
          node.addEventListener("click", () => {
            setTimeout(() => {
              applyCommentColors();
            }, 2000);
          });
          // Once button is found and listener added, disconnect observer
          buttonObserver.disconnect();
        }
      });
    });
  });

  // Start observing the document for the addition of the button
  buttonObserver.observe(document.body, { childList: true, subtree: true });

  // Cactus Comments Reply System
  class CactusReplySystem {
    constructor() {
      console.log("CactusReplySystem constructor called");
      this.replyButtons = new Map();
      this.init();
    }

    init() {
      console.log("Initializing reply system");
      this.waitForComments();
      this.setupMutationObserver();
      this.setupCommentSubmissionHandler();

      // Set up textarea listener after a delay to ensure cactus is ready
      setTimeout(() => this.setupTextareaListener(), 3000);
    }

    setupCommentSubmissionHandler() {
      // Wait for cactus editor to be ready
      const checkForEditor = () => {
        const cactusEditor = document.querySelector(".cactus-editor");

        if (cactusEditor) {
          this.interceptCommentSubmission();
        } else {
          setTimeout(checkForEditor, 1000);
        }
      };

      setTimeout(checkForEditor, 2000);
    }

    interceptCommentSubmission() {
      const cactusEditor = document.querySelector(".cactus-editor");
      if (!cactusEditor) return;

      // Find the submit button
      const submitButton = cactusEditor.querySelector(".cactus-send-button, .cactus-button");

      if (submitButton) {
        // Remove any existing listeners and add our own
        const newSubmitButton = submitButton.cloneNode(true);
        submitButton.parentNode.replaceChild(newSubmitButton, submitButton);

        newSubmitButton.addEventListener("click", (e) => {
          this.handleCommentSubmit(e);
        });

        console.log("Comment submission interceptor set up");
      }
    }

    handleCommentSubmit(e) {
      const quoteBox = document.getElementById("cactus-active-quote");
      const textarea = document.querySelector(".cactus-editor-textarea");

      if (quoteBox && textarea) {
        // Get quote data
        const quoteName = quoteBox.querySelector(".cactus-quote-title strong").textContent;
        const quoteContent = quoteBox.querySelector(".cactus-quote-content").textContent;

        // Get user's message
        const userMessage = textarea.value.trim();

        if (userMessage) {
          // Format the final message with quote
          const finalMessage = `**@Reply to ${quoteName}:**\n\n> ${quoteContent}\n\n---\n\n${userMessage}`;

          // Update textarea with formatted message
          textarea.value = finalMessage;

          // Trigger input event
          const inputEvent = new Event("input", { bubbles: true });
          textarea.dispatchEvent(inputEvent);

          // Hide quote box
          this.hideQuoteBox();

          console.log("Quote merged with user message");
        } else {
          // If no user message, prevent submission and show warning
          e.preventDefault();
          e.stopPropagation();
          this.showNotification("Please enter your reply message", "warning");
          return false;
        }
      }

      // Let the original submission continue
      return true;
        if (cactusEditor) {
          this.interceptCommentSubmission();


    waitForComments() {
      console.log("Waiting for comments to load");

      const checkForComments = () => {
        const comments = document.querySelectorAll(".cactus-comment");
        console.log(`Found ${comments.length} comments`);

        if (comments.length > 0) {
          this.addReplyButtons();
        } else {
          setTimeout(checkForComments, 1000);
        }
      };
      checkForComments();
    }

    setupMutationObserver() {
      const commentsContainer = document.querySelector("#comment-section");
      if (!commentsContainer) return;

      const observer = new MutationObserver((mutations) => {
        let shouldUpdate = false;
        mutations.forEach((mutation) => {
          if (mutation.addedNodes.length > 0) {
            mutation.addedNodes.forEach((node) => {
              if (
                node.nodeType === 1 &&
                (node.classList?.contains("cactus-comment") ||
                  node.querySelector?.(".cactus-comment"))
              ) {
                shouldUpdate = true;
              }
            });
          }
        });

        if (shouldUpdate) {
          console.log("New comments detected, adding reply buttons");
          setTimeout(() => this.addReplyButtons(), 500);
        }
      });

      observer.observe(commentsContainer, {
        childList: true,
        subtree: true,
      });
    }

    addReplyButtons() {
      const comments = document.querySelectorAll(".cactus-comment");
      console.log(`Adding reply buttons to ${comments.length} comments`);

      comments.forEach((comment, index) => {
        const commentData = this.extractCommentData(comment);
        console.log(
          `Comment ${index}: name = ${commentData.name}, timestamp = ${commentData.timestamp}`
        );
        if (
          !commentData.timestamp ||
          this.replyButtons.has(commentData.timestamp)
        )
          return;

        const replyButton = this.createReplyButton(commentData);

        const commentBody = comment.querySelector(".cactus-comment-body");
        if (commentBody) {
          commentBody.appendChild(replyButton);
          this.replyButtons.set(commentData.timestamp, replyButton);
          console.log(`Added reply button for comment by ${commentData.name}`);
        }
      });
    }

    extractCommentData(comment) {
      // Extract the display name
      const displayNameElement = comment.querySelector(
        ".cactus-comment-displayname"
      );
      const name = displayNameElement
        ? displayNameElement.textContent.trim()
        : "Anonymous";

      // Extract the original message content
      const messageElement = comment.querySelector(
        ".cactus-message-text, .cactus-comment-body .cactus-message-text"
      );
      let originalMessage = "";
      if (messageElement) {
        originalMessage = messageElement.textContent.trim();
      } else {
        // Fallback: try to get text from comment body, excluding the header
        const commentBody = comment.querySelector(".cactus-comment-body");
        if (commentBody) {
          // Clone the element to avoid modifying the original
          const bodyClone = commentBody.cloneNode(true);
          // Remove any reply buttons we might have added
          const replyButtons = bodyClone.querySelectorAll(
            ".cactus-reply-button, .cactus-reply-container"
          );
          replyButtons.forEach((btn) => btn.remove());
          originalMessage = bodyClone.textContent.trim();
        }
      }

      // Extract timestamp for unique identification
      const timeElement = comment.querySelector(".cactus-comment-time");
      let timestamp;
      if (timeElement && timeElement.dateTime) {
        timestamp = timeElement.dateTime;
      } else if (timeElement) {
        timestamp = timeElement.textContent.trim();
      } else {
        const commentId = comment.id || comment.dataset.id;
        if (commentId) {
          timestamp = commentId;
        } else {
          const content = comment.textContent.trim();
          timestamp = this.generateHash(content);
        }
      }

      return { name, timestamp, originalMessage };
    }

    generateHash(str) {
      let hash = 0;
      for (let i = 0; i < str.length; i++) {
        const char = str.charCodeAt(i);
        hash = (hash << 5) - hash + char;
        hash = hash & hash;
      }
      return Math.abs(hash).toString();
    }

    createReplyButton(commentData) {
      const button = document.createElement("button");
      button.className = "cactus-reply-button";
      button.innerHTML = "↩️ Reply";
      button.title = `Reply to ${commentData.name}`;

      button.addEventListener("click", (e) => {
        e.preventDefault();

        // Visual feedback
        const originalText = button.innerHTML;
        button.innerHTML = "✓ Added to comment";
        button.style.background = "#28a745";

        // Reset after 2 seconds
        setTimeout(() => {
          button.innerHTML = originalText;
          button.style.background = "";
        }, 2000);

        this.handleReplyClick(commentData);
      });

      return button;
    }

    handleReplyClick(commentData) {
      console.log("Reply button clicked for:", commentData.name);

      // Show the quote box instead of inserting text
      this.showQuoteBox(commentData);

      // Scroll to the main comment form
      this.scrollToMainForm();
    }

    showQuoteBox(commentData) {
      // Remove any existing quote box
      this.hideQuoteBox();

      // Find the cactus editor
      const cactusEditor = document.querySelector(".cactus-editor");
      if (!cactusEditor) {
        this.showNotification("Could not find comment editor", "warning");
        return;
      }

      // Create the quote box
      const quoteBox = this.createQuoteBox(commentData);

      // Insert the quote box before the textarea
      const textarea = cactusEditor.querySelector(".cactus-editor-textarea");
      if (textarea) {
        cactusEditor.insertBefore(quoteBox, textarea);

        // Focus the textarea
        textarea.focus();

        // Show notification
        this.showNotification(`Replying to ${commentData.name}`);
      }
    }

    createQuoteBox(commentData) {
      const quoteContainer = document.createElement("div");
      quoteContainer.className = "cactus-quote-box";
      quoteContainer.id = "cactus-active-quote";

      // Truncate message for display
      let displayMessage = commentData.originalMessage || "No message content";
      if (displayMessage.length > 200) {
        displayMessage = displayMessage.substring(0, 200) + "...";
      }

      quoteContainer.innerHTML = `
        <div class="cactus-quote-header">
          <span class="cactus-quote-icon">💬</span>
          <span class="cactus-quote-title">Replying to <strong>${commentData.name}</strong></span>
          <button class="cactus-quote-close" title="Cancel reply">×</button>
        </div>
        <div class="cactus-quote-content">
          "${displayMessage}"
        </div>
        <div class="cactus-quote-footer">
          <small>💡 Your reply will be posted with this quote. Click × to cancel.</small>
        </div>
      `;

      // Add close button functionality
      const closeButton = quoteContainer.querySelector(".cactus-quote-close");
      closeButton.addEventListener("click", () => {
        this.hideQuoteBox();
      });

      return quoteContainer;
    }

    hideQuoteBox() {
      const existingQuote = document.getElementById("cactus-active-quote");
      if (existingQuote) {
        existingQuote.style.animation = "slideUp 0.3s ease-in";
        setTimeout(() => existingQuote.remove(), 300);
      }
    }

    setupTextareaListener() {
      const textarea = document.querySelector(".cactus-editor-textarea");
      if (textarea) {
        // Add listener to clear quote box when user starts typing a fresh comment
        textarea.addEventListener("focus", () => {
          // Only clear if textarea is empty (indicating a fresh comment, not editing)
          if (!textarea.value.trim()) {
            const quoteBox = document.getElementById("cactus-active-quote");
            if (quoteBox) {
              // Ask user if they want to cancel the reply
              if (confirm("Cancel reply and start a new comment?")) {
                this.hideQuoteBox();
              }
            }
          }
        });
      }
    }

    // Modified to handle quote box data when submitting
    interceptCommentSubmission() {
      const cactusEditor = document.querySelector(".cactus-editor");
      if (!cactusEditor) return;

      const form = cactusEditor.closest("form") || cactusEditor.querySelector("form");
      const submitButton = cactusEditor.querySelector(".cactus-send-button, .cactus-button");

      if (submitButton) {
        submitButton.addEventListener("click", (e) => {
          this.handleCommentSubmit(e);
        });
      }
    }

    handleCommentSubmit(e) {
      const quoteBox = document.getElementById("cactus-active-quote");
      const textarea = document.querySelector(".cactus-editor-textarea");

      if (quoteBox && textarea) {
        // Get quote data
        const quoteName = quoteBox.querySelector(".cactus-quote-title strong").textContent;
        const quoteContent = quoteBox.querySelector(".cactus-quote-content").textContent;

        // Get user's message
        const userMessage = textarea.value.trim();

        if (userMessage) {
          // Format the final message with quote
          const finalMessage = `**@Reply to ${quoteName}:**\n\n> ${quoteContent}\n\n---\n\n${userMessage}`;

          // Update textarea with formatted message
          textarea.value = finalMessage;

          // Trigger input event
          const event = new Event("input", { bubbles: true });
          textarea.dispatchEvent(event);

          // Hide quote box
          this.hideQuoteBox();
        }
      }
    }

    scrollToMainForm() {
      // Target the specific cactus editor textarea
      let mainForm = document.querySelector(".cactus-editor-textarea");

      console.log("Scrolling to main form:", mainForm);
      if (mainForm) {
        mainForm.scrollIntoView({ behavior: "smooth", block: "center" });

        // Focus the textarea and position cursor at the end after scrolling
        setTimeout(() => {
          mainForm.focus();
          // Position cursor at the end of the text
          const textLength = mainForm.value.length;
          mainForm.setSelectionRange(textLength, textLength);
        }, 500);
      } else {
        console.log("Could not find .cactus-editor-textarea to scroll to");
      }
    }

    showNotification(message, type = "success") {
      // Remove any existing notifications
      const existingNotification = document.querySelector(
        ".cactus-reply-notification"
      );
      if (existingNotification) {
        existingNotification.remove();
      }

      const notification = document.createElement("div");
      notification.className = "cactus-reply-notification";
      notification.textContent = message;

      const bgColor = type === "success" ? "#28a745" : "#ffc107";
      const textColor = type === "success" ? "white" : "#212529";

      notification.style.cssText = `
        position: fixed;
        top: 20px;
        right: 20px;
        background: ${bgColor};
        color: ${textColor};
        padding: 12px 20px;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 500;
        box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        z-index: 10000;
        animation: slideInRight 0.3s ease-out;
      `;

      // Add animation keyframes if not already added
      if (!document.querySelector("#reply-notification-styles")) {
        const style = document.createElement("style");
        style.id = "reply-notification-styles";
        style.textContent = `
          @keyframes slideInRight {
            from { transform: translateX(100%); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
          }
          @keyframes slideOutRight {
            from { transform: translateX(0); opacity: 1; }
            to { transform: translateX(100%); opacity: 0; }
          }
        `;
        document.head.appendChild(style);
      }

      document.body.appendChild(notification);

      // Auto-remove after 3 seconds
      setTimeout(() => {
        notification.style.animation = "slideOutRight 0.3s ease-in";
        setTimeout(() => notification.remove(), 300);
      }, 3000);
    }

    copyToClipboard(text) {
      if (navigator.clipboard && window.isSecureContext) {
        navigator.clipboard.writeText(text);
      } else {
        const textArea = document.createElement("textarea");
        textArea.value = text;
        textArea.style.position = "fixed";
        textArea.style.left = "-999999px";
        textArea.style.top = "-999999px";
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();

        try {
          document.execCommand("copy");
        } catch (err) {
          console.error("Failed to copy text: ", err);
        }

        document.body.removeChild(textArea);
      }
    }
  }

  // Initialize the reply system after cactus is fully loaded
  console.log("Setting up reply system initialization");

  // Wait for cactus to be fully initialized before adding our functionality
  function waitForCactusReady() {
    const cactusEditor = document.querySelector(".cactus-editor");
    const cactusTextarea = document.querySelector(".cactus-editor-textarea");

    if (cactusEditor && cactusTextarea) {
      console.log("Cactus is ready, creating CactusReplySystem instance");
      window.cactusReplySystem = new CactusReplySystem();
    } else {
      console.log("Cactus not ready yet, retrying...");
      setTimeout(waitForCactusReady, 1000);
    }
  }

  // Start checking after a delay to let cactus initialize
  setTimeout(waitForCactusReady, 5000);

  // Function to style quote blocks in comments
  function styleQuoteBlocks() {
    document
      .querySelectorAll(".cactus-comment-body, .cactus-message-text")
      .forEach((element) => {
        const paragraphs = element.querySelectorAll("p");
        paragraphs.forEach((p) => {
          const text = p.textContent.trim();
          // Check if paragraph starts with > (markdown quote)
          if (text.startsWith(">")) {
            p.style.cssText = `
            background: rgba(0, 124, 186, 0.05);
            border-left: 4px solid #007cba;
            padding: 8px 12px;
            margin: 8px 0;
            border-radius: 0 4px 4px 0;
            font-style: italic;
            color: var(--cactus-text-color--soft);
          `;
            // Remove the > character for cleaner display
            p.textContent = text.substring(1).trim();
          }
        });
      });
  }

  // Apply quote styling when comments load
  const quoteObserver = new MutationObserver((mutations) => {
    let shouldStyle = false;
    mutations.forEach((mutation) => {
      if (mutation.addedNodes.length > 0) {
        mutation.addedNodes.forEach((node) => {
          if (
            node.nodeType === 1 &&
            (node.classList?.contains("cactus-comment") ||
              node.querySelector?.(".cactus-comment"))
          ) {
            shouldStyle = true;
          }
        });
      }
    });

    if (shouldStyle) {
      setTimeout(styleQuoteBlocks, 100);
    }
  });

  // Start observing for quote styling
  const commentSection = document.querySelector("#comment-section");
  if (commentSection) {
    quoteObserver.observe(commentSection, { childList: true, subtree: true });
  }

  // Apply initial quote styling
  setTimeout(styleQuoteBlocks, 6000);
</script>
